from __future__ import annotations

import math
from typing import Dict, List, Set

from app.schemas.fsm import FSMDefinition, FSMState, FSMTransition
from app.services.fsm_validation import SUPPORTED_SIGNALS


def _state_bits(num_states: int) -> int:
    return max(1, math.ceil(math.log2(max(num_states, 1))))


def generate_verilog_from_fsm(
    fsm: FSMDefinition,
    module_name: str = "elevator_fsm",
) -> str:
    state_ids: List[str] = [st.id for st in fsm.states]
    initial_state = next((st.id for st in fsm.states if st.is_initial), state_ids[0])
    bits = _state_bits(len(state_ids))

    state_map: Dict[str, int] = {sid: idx for idx, sid in enumerate(state_ids)}

    signals_used: Set[str] = set()
    for tr in fsm.transitions:
        cond = (tr.condition or "").strip().lower()
        if cond in ("", "*", "always"):
            continue
        if cond in SUPPORTED_SIGNALS:
            signals_used.add(cond)

    ports: List[str] = [
        "input  wire        clk",
        "input  wire        rst",
    ]
    ports.extend([f"input  wire        {sig}" for sig in sorted(signals_used)])
    ports.append(f"output reg [{bits - 1}:0]  state")
    ports_block = ",\n    ".join(ports)

    localparams = ",\n    ".join(
        [
            f"{sid.upper():<12} = {bits}'d{idx}"
            for sid, idx in state_map.items()
        ]
    )

    def render_transition_block(state: FSMState) -> str:
        trs = [tr for tr in fsm.transitions if tr.from_state_id == state.id]
        if not trs:
            return "      // no transitions\n"
        lines: List[str] = []
        for idx, tr in enumerate(trs):
            cond = (tr.condition or "").strip().lower()
            if cond in ("", "*", "always"):
                cond_expr = "1'b1"
            else:
                cond_expr = cond
            prefix = "if" if idx == 0 else "else if"
            lines.append(
                f"      {prefix} ({cond_expr}) begin\n"
                f"        next_state = {tr.to_state_id.upper()};\n"
                f"      end"
            )
        return "\n".join(lines) + "\n"

    case_items: List[str] = []
    for st in fsm.states:
        case_items.append(
            f"    {st.id.upper()}: begin\n"
            f"{render_transition_block(st)}"
            f"    end"
        )

    case_block = "\n".join(case_items)

    verilog = f"""// Auto-generated by Smart Elevator FSM backend.
// States: {', '.join(state_ids)}

module {module_name} (
    {ports_block}
);

  // state encoding
  localparam
    {localparams};

  reg [{bits - 1}:0] curr_state;
  reg [{bits - 1}:0] next_state;

  always @(posedge clk or posedge rst) begin
    if (rst)
      curr_state <= {initial_state.upper()};
    else
      curr_state <= next_state;
  end

  always @(*) begin
    next_state = curr_state;
    case (curr_state)
{case_block}
      default: next_state = {initial_state.upper()};
    endcase
  end

  always @(*) begin
    state = curr_state;
  end

endmodule
"""
    return verilog
